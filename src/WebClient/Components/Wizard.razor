@rendermode InteractiveAuto
@using WebClient.Stores
@inject IStoreFactory StoreFactory
@inject NavigationManager Navigation


<div class="wizard">
    <div class="wizard__content">
        <CascadingValue Value="@this">
            @ChildContent
        </CascadingValue>
    </div>
    <div class="wizard__buttons">
        @if (PreviousStepName is not null)
        {
            <button class="btn btn--md btn--primary"
                    disabled="@(PreviousStepName is null)"
                    @onclick="GoToPreviousStep">
                Previous
            </button>
        }
        <button class="btn btn--md btn--primary"
                @onclick="GoToNextStepOrSubmit">
            @(NextStepName is not null ? "Next" : "Submit")
        </button>
    </div>
</div>


@code {
    [Parameter] public RenderFragment ChildContent { get; set; } = null!;

    [Parameter] public string? ActiveStepName { get; set; }

    [Parameter, EditorRequired] public string BaseRoute { get; set; } = null!;


    [Parameter] public EventCallback OnSubmit { get; set; }


    public IStore Store { get; private set; }

    private List<string> StepNames { get; set; } = [];

    private List<string> InactiveStepNames { get; set; } = [];

    private string? NextStepName { get; set; }

    private string? PreviousStepName { get; set; }


    protected override void OnParametersSet()
    {
        Store = StoreFactory.Create<BrowserSessionStore>("BaseRoute:WizardModelStore");
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender) return;


        ActiveStepName ??= StepNames.FirstOrDefault()
                           ?? throw new InvalidOperationException("No steps were defined");
        UpdateNextAndPrevious();
        StateHasChanged();
    }

    public void AddStep(string stepName)
    {
        if (!StepNames.Contains(stepName))
            StepNames.Add(stepName);
    }

    public void DeactivateStep(string stepName)
    {
        if (stepName == ActiveStepName)
            throw new InvalidOperationException("The currently active step cannot be deactivated.");

        if (InactiveStepNames.Contains(stepName)) return;

        InactiveStepNames.Add(stepName);
        UpdateNextAndPrevious();
        StateHasChanged();
    }

    public void ActivateStep(string stepName)
    {
        if (!InactiveStepNames.Contains(stepName)) return;

        InactiveStepNames.Remove(stepName);
        UpdateNextAndPrevious();
        StateHasChanged();
    }

    public void Refresh() => StateHasChanged();

    internal void NavigateToStep(string routeParam)
    {
        Navigation.NavigateTo($"{BaseRoute}/{routeParam}");
    }

    internal bool IsStepActive(string stepName) => ActiveStepName == stepName;

    private void UpdateNextAndPrevious()
    {
        var enabledStepNames = StepNames.Where(sn => !InactiveStepNames.Contains(sn));
        var stepNames = enabledStepNames as string[] ?? enabledStepNames.ToArray();

        PreviousStepName = stepNames
            .TakeWhile(sn => sn != ActiveStepName)
            .LastOrDefault();
        Console.WriteLine($"Active Step Name = {ActiveStepName}");
        Console.WriteLine($"Previous Step Name = {PreviousStepName}");

        NextStepName = stepNames
            .SkipWhile(sn => sn != ActiveStepName)
            .Skip(1)
            .FirstOrDefault();
    }

    private void GoToPreviousStep()
    {
        if (PreviousStepName is not null)
            NavigateToStep(PreviousStepName);
    }

    private void GoToNextStep()
    {
        if (NextStepName is not null)
            NavigateToStep(NextStepName);
    }

    private void Submit()
    {
        if (!OnSubmit.HasDelegate) return;

        OnSubmit.InvokeAsync();
    }

    private void GoToNextStepOrSubmit()
    {
        if (NextStepName is not null)
            GoToNextStep();
        else
            Submit();
    }

}